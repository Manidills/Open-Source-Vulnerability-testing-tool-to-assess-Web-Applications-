#!/usr/bin/env python
# -*- coding:utf-8 -*-
import os
import codecs
import time
import random
import glob
import configparser
import urllib3
from docopt import docopt
from urllib3 import util
from util import Utilty
from modules.VersionCheckerML import VersionCheckerML
from modules.Report import CreateReport
from modules.PageTypeChecker import PageChecker
from modules.ContentExplorer import ContentExplorer
from modules.SpiderControl import SpiderControl
from urllib3.exceptions import InsecureRequestWarning
urllib3.disable_warnings(InsecureRequestWarning)

# Type of printing.
OK = 'ok'         # [*]
NOTE = 'note'     # [+]
FAIL = 'fail'     # [-]
WARNING = 'warn'  # [!]
NONE = 'none'     # No label.


# Get target information.
def get_target_info(full_path, utility):
    utility.write_log(20, '[In] Get target information [{}].'.format(os.path.basename(__file__)))
    protocol = []
    fqdn = []
    port = []
    path = []
    try:
        with codecs.open(os.path.join(full_path, 'host.txt'), 'r', 'utf-8') as fin:
            targets = fin.readlines()
            for target in targets:
                items = target.replace('\r', '').replace('\n', '').split(' ')
                if len(items) != 4:
                    utility.print_message(FAIL, 'Invalid target record : {}'.format(target))
                    utility.write_log(30, 'Invalid target record : {}'.format(target))
                    continue
                protocol.append(items[0])
                fqdn.append(items[1])
                port.append(items[2])
                path.append(items[3])
    except Exception as e:
        utility.print_message(FAIL, 'Invalid file: {}'.format(e))
        utility.write_log(30, 'Invalid file: {}'.format(e))

    utility.write_log(20, '[Out] Get target information [{}].'.format(os.path.basename(__file__)))
    return protocol, fqdn, port, path

# Display banner.
def show_banner(utility):
    banner = """
^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
""" + 'by ' + os.path.basename(__file__)
    utility.print_message(NONE, banner)
    show_credit(utility)
    time.sleep(utility.banner_delay)


# Show credit.
def show_credit(utility):
    credit = u"""
       WE FIND
    """
    utility.print_message(NONE, credit)




# Define command option.
__doc__ = """{f}
usage:
    {f} [-s] [-m] [-g] [-e] [-c] [-p] [-l <log_path>]
    {f} -h | --help
options:
    -s   Optional : Examine cloud service.
    -m   Optional : Analyze HTTP response for identify product/version using Machine Learning.
    -g   Optional : Google Custom Search for identify product/version.
    -e   Optional : Explore default path of product.
    -c   Optional : Discover open ports and wrong ssl server certification using Censys.
    -p   Optional : Execute exploit module using Metasploit.
    -l   Optional : Analyze log based HTTP response for identify product/version.
    -h --help     Show this help message and exit.
""".format(f=__file__)


# Parse command arguments.
def command_parse(utility):
    utility.write_log(20, '[In] Parse command options [{}].'.format(os.path.basename(__file__)))

    args = docopt(__doc__)
    opt_ml = args['-m']
    opt_explore = args['-e']
    opt_log = args['-l']
    opt_log_path = args['<log_path>']

    utility.write_log(20, '[Out] Parse command options [{}].'.format(os.path.basename(__file__)))
    return  opt_ml, opt_explore, opt_log, opt_log_path


# main.
if __name__ == '__main__':
    file_name = os.path.basename(__file__)
    full_path = os.path.dirname(os.path.abspath(__file__))

    utility = Utilty()
    utility.write_log(20, '[In] GyoiThon [{}].'.format(file_name))

    # Get command arguments.
    opt_ml, opt_explore, opt_log, opt_log_path = command_parse(utility)

    # Read config.ini.
    config = configparser.ConfigParser()
    config.read(os.path.join(full_path, 'config.ini'))

    # Common setting value.
    log_path = ''
    method_crawl = ''
    method_log = ''
    max_target_url = 0
    max_target_byte = 0
    is_scramble = False
    try:
        log_dir = config['Common']['log_path']
        log_path = os.path.join(full_path, log_dir)
        method_crawl = config['Common']['method_crawl']
        method_log = config['Common']['method_log']
        max_target_url = int(config['Common']['max_target_url'])
        max_target_byte = int(config['Common']['max_target_byte'])
        if int(config['Common']['scramble']) == 1:
            is_scramble = True

    except Exception as e:
        msg = 'Reading config.ini is failure : {}'.format(e)
        utility.print_exception(e, msg)
        utility.write_log(40, msg)
        utility.write_log(20, '[Out] GyoiThon [{}].'.format(file_name))
        exit(1)

   

    # Create instances.
    version_checker_ml = VersionCheckerML(utility)
    page_checker = PageChecker(utility)
    content_explorer = ContentExplorer(utility)
    spider = SpiderControl(utility)
    report = CreateReport(utility)

    # Get target information from "host.txt".
    protocol_list, fqdn_list, port_list, path_list = get_target_info(full_path, utility)

    # Start investigation.
    for idx in range(len(fqdn_list)):
        # Check parameters.
        msg = 'investigation : {}, {}, {}, {}'.format(protocol_list[idx], fqdn_list[idx], port_list[idx], path_list[idx])
        utility.write_log(20, 'Start ' + msg)
        if utility.check_arg_value(protocol_list[idx], fqdn_list[idx], port_list[idx], path_list[idx]) is False:
            msg = 'Invalid parameter : {}, {}, {}, {}'.format(protocol_list[idx], fqdn_list[idx],
                                                              port_list[idx], path_list[idx])
            utility.print_message(FAIL, msg)
            utility.write_log(30, msg)
            continue

        # Create report header.
        report.create_report_header(fqdn_list[idx], port_list[idx])

        # Check encoding.
        test_url = ''
        if int(port_list[idx]) in [80, 443]:
            test_url = protocol_list[idx] + '://' + fqdn_list[idx] + path_list[idx]
        else:
            test_url = protocol_list[idx] + '://' + fqdn_list[idx] + ':' + port_list[idx] + path_list[idx]
        _, server_header, res_header, res_body, encoding = utility.send_request('GET', test_url)

       

        # Analysis HTTP responses.
        product_list = []
        if opt_log:
            # Check stored logs.
            if os.path.exists(opt_log_path) is False:
                utility.print_message(FAIL, 'Path not found: {}'.format(opt_log_path))
                utility.write_log(30, 'Path not found : {}'.format(opt_log_path))
                utility.write_log(20, '[Out] Analyze log [{}].'.format(os.path.basename(__file__)))
            else:
                log_list = glob.glob(os.path.join(opt_log_path, '*.log'))
                for log_idx, path in enumerate(log_list):
                    try:
                        with codecs.open(path, 'r', 'utf-8') as fin:
                            target_log = fin.read()
                            date = utility.get_current_date('%Y%m%d%H%M%S%f')[:-3]
                            print_date = utility.transform_date_string(
                                utility.transform_date_object(date[:-3], '%Y%m%d%H%M%S'))

                            msg = '{}/{} Checking : Log: {}'.format(log_idx + 1, len(log_list), path)
                            utility.print_message(OK, msg)
                            utility.write_log(20, msg)

                            # Cutting response byte.
                            if max_target_byte != 0 and (max_target_byte < len(target_log)):
                                utility.print_message(WARNING, 'Cutting response byte {} to {}.'
                                                      .format(len(target_log), max_target_byte))
                                target_log = target_log[:max_target_byte]

                            

                            # Check product name/version using Machine Learning.
                            if opt_ml:
                                product_list.extend(version_checker_ml.get_product_name(target_log))

                            
                           

                            # Create report.
                            report.create_report_body('-',
                                                      fqdn_list[idx],
                                                      port_list[idx],
                                                      method_log,
                                                      product_list,
                                                      {},
                                                      comments,
                                                      '-',
                                                      path,
                                                      print_date)
                    except Exception as e:
                        utility.print_exception(e, 'Not read log : {}'.format(path))
                        utility.write_log(30, 'Not read log : {}'.format(path))
        else:
            # Gather target url using Spider.
            spider.utility.encoding = encoding
            web_target_info = spider.run_spider(protocol_list[idx], fqdn_list[idx], port_list[idx], path_list[idx])

            # Get HTTP responses.
            for target in web_target_info:
                # Scramble and Cutting loop count.
                target_list = target[2]
                if is_scramble is True:
                    utility.print_message(WARNING, 'Scramble target list.')
                    target_list = random.sample(target[2], len(target[2]))
                if max_target_url != 0 and max_target_url < len(target_list):
                    utility.print_message(WARNING, 'Cutting target list {} to {}.'.format(len(target[2]),
                                                                                          max_target_url))
                    target_list = target_list[:max_target_url]

                for count, target_url in enumerate(target_list):
                    utility.print_message(NOTE, '{}/{} Start analyzing: {}'.format(count+1,
                                                                                   len(target_list),
                                                                                   target_url))

                    # Check target url.
                    parsed = None
                    try:
                        parsed = util.parse_url(target_url)
                    except Exception as e:
                        utility.print_exception(e, 'Parsed error : {}'.format(target_url))
                        utility.write_log(30, 'Parsed error : {}'.format(target_url))
                        continue

                    # Get HTTP response (header + body).
                    date = utility.get_current_date('%Y%m%d%H%M%S%f')[:-3]
                    print_date = utility.transform_date_string(utility.transform_date_object(date[:-3], '%Y%m%d%H%M%S'))
                    _, server_header, res_header, res_body, _ = utility.send_request('GET', target_url)

                    # Write log.
                    log_name = protocol_list[idx] + '_' + fqdn_list[idx] + '_' + str(port_list[idx]) + '_' + date + '.log'
                    log_path_fqdn = os.path.join(log_path, fqdn_list[idx] + '_' + str(port_list[idx]))
                    if os.path.exists(log_path_fqdn) is False:
                        os.mkdir(log_path_fqdn)
                    log_file = os.path.join(log_path_fqdn, log_name)
                    with codecs.open(log_file, 'w', 'utf-8') as fout:
                        fout.write(target_url + '\n\n' + res_header + '\n\n' + res_body)

                    # Cutting response byte.
                    if max_target_byte != 0 and (max_target_byte < len(res_body)):
                        utility.print_message(WARNING, 'Cutting response byte {} to {}.'.format(len(res_body),
                                                                                                max_target_byte))
                        res_body = res_body[:max_target_byte]

                    

                    # Check product name/version using Machine Learning.
                    if opt_ml:
                        product_list.extend(version_checker_ml.get_product_name(res_header + res_body))

                   

                    


                    # Check login page.
                    page_type = page_checker.judge_page_type(target_url, res_header + res_body)

                 

        # Check unnecessary contents using Google Hack.
       
        # Check unnecessary contents using Explore contents.
        if opt_explore:
            product_list.extend(content_explorer.content_explorer(cve_explorer,
                                                                  protocol_list[idx],
                                                                  fqdn_list[idx],
                                                                  port_list[idx],
                                                                  path_list[idx],
                                                                  report,
                                                                  max_target_byte))

       

        utility.write_log(20, 'End ' + msg)

    print(os.path.basename(__file__) + ' finish!!')
    utility.write_log(20, '[Out] GyoiThon [{}].'.format(file_name))
